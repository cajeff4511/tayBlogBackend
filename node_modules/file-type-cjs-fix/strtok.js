const { EndOfStreamError, StreamReader } = require('peek-readable')
const AbstractTokenizer = require('./tokenizer')

const maxBufferSize = 256000

exports.BufferTokenizer = class BufferTokenizer extends AbstractTokenizer {
  constructor(uint8Array, fileInfo) {
    super(fileInfo)
    this.uint8Array = uint8Array
    this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : uint8Array.length
  }
  async readBuffer(uint8Array, options) {
    if (options && options.position) {
      if (options.position < this.position) {
        throw new Error('`options.position` must be equal or greater than `tokenizer.position`')
      }
      this.position = options.position
    }
    const bytesRead = await this.peekBuffer(uint8Array, options)
    this.position += bytesRead
    return bytesRead
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options)
    const bytes2read = Math.min(this.uint8Array.length - normOptions.position, normOptions.length)
    if ((!normOptions.mayBeLess) && bytes2read < normOptions.length) {
      throw new EndOfStreamError()
    }
    else {
      uint8Array.set(this.uint8Array.subarray(normOptions.position, normOptions.position + bytes2read), normOptions.offset)
      return bytes2read
    }
  }
  async close() {
    // empty
  }
}

exports.ReadStreamTokenizer = class ReadStreamTokenizer extends AbstractTokenizer {
  constructor(stream, fileInfo) {
    super(fileInfo)
    this.streamReader = new StreamReader(stream)
  }
  async getFileInfo() {
    return this.fileInfo
  }
  async readBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options)
    const skipBytes = normOptions.position - this.position
    if (skipBytes > 0) {
      await this.ignore(skipBytes)
      return this.readBuffer(uint8Array, options)
    }
    else if (skipBytes < 0) {
      throw new Error('`options.position` must be equal or greater than `tokenizer.position`')
    }
    if (normOptions.length === 0) {
      return 0
    }
    const bytesRead = await this.streamReader.read(uint8Array, normOptions.offset, normOptions.length)
    this.position += bytesRead
    if ((!options || !options.mayBeLess) && bytesRead < normOptions.length) {
      throw new EndOfStreamError()
    }
    return bytesRead
  }
  async peekBuffer(uint8Array, options) {
    const normOptions = this.normalizeOptions(uint8Array, options)
    let bytesRead = 0
    if (normOptions.position) {
      const skipBytes = normOptions.position - this.position
      if (skipBytes > 0) {
        const skipBuffer = new Uint8Array(normOptions.length + skipBytes)
        bytesRead = await this.peekBuffer(skipBuffer, { mayBeLess: normOptions.mayBeLess })
        uint8Array.set(skipBuffer.subarray(skipBytes), normOptions.offset)
        return bytesRead - skipBytes
      }
      else if (skipBytes < 0) {
        throw new Error('Cannot peek from a negative offset in a stream')
      }
    }
    if (normOptions.length > 0) {
      try {
        bytesRead = await this.streamReader.peek(uint8Array, normOptions.offset, normOptions.length)
      }
      catch (err) {
        if (options && options.mayBeLess && err instanceof EndOfStreamError) {
          return 0
        }
        throw err
      }
      if ((!normOptions.mayBeLess) && bytesRead < normOptions.length) {
        throw new EndOfStreamError()
      }
    }
    return bytesRead
  }
  async ignore(length) {
    // debug(`ignore ${this.position}...${this.position + length - 1}`)
    const bufSize = Math.min(maxBufferSize, length)
    const buf = new Uint8Array(bufSize)
    let totBytesRead = 0
    while (totBytesRead < length) {
      const remaining = length - totBytesRead
      const bytesRead = await this.readBuffer(buf, { length: Math.min(bufSize, remaining) })
      if (bytesRead < 0) {
        return bytesRead
      }
      totBytesRead += bytesRead
    }
    return totBytesRead
  }
}

// Exports
exports.fromStream = async (stream, fileInfo) => {
  fileInfo = fileInfo ? fileInfo : {}
  return new exports.ReadStreamTokenizer(stream, fileInfo)
}

exports.fromBuffer = (uint8Array, fileInfo) => {
  return new exports.BufferTokenizer(uint8Array, fileInfo)
}

